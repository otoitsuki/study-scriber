---
description:
globs:
alwaysApply: false
---
<!-- Source: https://github.com/arthow4n/live-language-mate/blob/master/CLAUDE.md -->

### Development Notes

- Uses shadcn/ui component library extensively
- In the default state without a specified style, the tweakcn clean-slate style is applied first: `npx shadcn@latest add https://tweakcn.com/r/themes/clean-slate.json`
- Responsive design with mobile-first approach
- Settings stored in localStorage with versioning


## TypeScript coding style and conventions

- Prefer named import/export over default import/export.
- Early return, early throw.
- In frontend Vitest test files, import explicitly the test helpers e.g. `import { beforeEach, describe, expect, `test`, vi } from 'vitest';`.
- Use Zod to validate and cast type as early as possible, this includes but not limit to handling the following scenarios: `any`, `unknown`, `DefaultBodyType`.
- Always assign unknown type to `const x: unknown = JSON.parse()`, `cosnt x: unknown = await request.json()`, `cosnt x: unknown = await response.json()`, then validate with Zod.
- Zod schemas are shared between frontend and backend.
- Zod schemas are in `src/schemas/`, you should find in there first to see if there's a schema you can reuse. You should not create Zod schemas outside of `src/schemas/`.
- Never use `any`, `as` type assertion or `!` non-null assertion operator, you should instead use type narrowing, for example in test you can use `expectToBeInstanceOf`, `expectToNotBeNull`, `expectToNotBeUndefined`, and outside of test `instanceof` or do a proper object validation with Zod.
- If you would declare an untyped object, instead you should either type it with e.g. `const x: X = {}` or `{} satisfies X`.
- Avoid optional function parameter, optional property, and default values. If you are about to add one or you see any of such usages, try to look around the related code paths and see if you can refactor to remove it. Default values should only be used when it's absolutely necessary.
- Throw if a logic not really optional:

```ts
// Bad: Is Y optional?
if (x instaceof X) { x.Y(); }

// Bad: Is Y optional?
x?.Y();

// Good: Type narrowing and early throw
if (!x instanceof X) { throw new Error(); }
x.Y();

// Best: Zod type narrowing and early throw, prefer .parse over .safeParse when possible.
zodSchema.parse(x);
x.Y();

// Compromise: Explain why Y is optional if Y is really optional.
x?.Y(); // Y is optional because ...
```

### In fronted, instead of X use Y

- `as` operator -> use Zod
- `console.error` -> `logError`
- `JSX.Element` -> `React.JSX.Element`
- `toBeTruthy`, `.not.toBeNull`, `toBeDefined`, `toBeInstanceOf` or `if (instanceof)` -> use the type narrowing expect helpers in `src/__tests__/typedExpectHelpers.ts`
- `getAllBy*()[*]` -> `getByTestId` or `getByText`
- `() => {}` empty mock -> `vi.fn()`
- `JSON.stringify(x)` if x is not typed -> `const x: X = {}; JSON.stringify(x)` or `JSON.stringify({} satisfies X)`
- `fireEvent` -> `userEvent`
- `vi.mock` -> never mock imported code, we write integration test and should not mock any decendant imports.



## Test

- When writing test, write integration test.
- Write integration test to cover business logic, if something can be clicked, input or be interacted in any other ways by the user, it should be covered by a test.
- When writing new test, make sure the test is genuinely new and not testing what another test has already covered. You should look for other existing test cases to understand if the test you are about to write is already covered by another test.
- Focus on testing the component/function's integrated behaviour, for example, if the import tree looks like A -> B -> C, you should not mock any of A/B/C, instead you should focus on testing if interacting with A as a whole gives you the expected result; in B's test you should not mock B/C and instead test interacting with B; and so on.
- You should only change a test file if you are fixing lint/type errors, or you made a change that requires update that test file.
- If you are only editing test, you should not change the existing code logic that in the test. If refactoring would make writing test easier, explain to the user and wait for feedback. You may add testid yourself if needed.
- If an action will make an API request, you should test whether the API will get the correctly formed request.
- Before you write or change any test code, make sure you step back and get a full picture first, by reading through the related code paths from beginning to end, and understanding how the code and data flows.
- Instead of fixing many test cases in one go, focus on fixing 1 test at a time, each test case should have its own todo item.
- `DragEvent`, `DataTransferItemList`, `DataTransfer`, `DOMRect` are polyfilled and can be used in test:

```ts
const event = new DragEvent('dragenter', {
  cancelable: true,
  bubbles: true,
});
event.dataTransfer?.items.add('hello world', 'text/plain');
```


## Test

- When writing test, write integration test.
- Write integration test to cover business logic, if something can be clicked, input or be interacted in any other ways by the user, it should be covered by a test.
- When writing new test, make sure the test is genuinely new and not testing what another test has already covered. You should look for other existing test cases to understand if the test you are about to write is already covered by another test.
- Focus on testing the component/function's integrated behaviour, for example, if the import tree looks like A -> B -> C, you should not mock any of A/B/C, instead you should focus on testing if interacting with A as a whole gives you the expected result; in B's test you should not mock B/C and instead test interacting with B; and so on.
- You should only change a test file if you are fixing lint/type errors, or you made a change that requires update that test file.
- If you are only editing test, you should not change the existing code logic that in the test. If refactoring would make writing test easier, explain to the user and wait for feedback. You may add testid yourself if needed.
- If an action will make an API request, you should test whether the API will get the correctly formed request.
- Before you write or change any test code, make sure you step back and get a full picture first, by reading through the related code paths from beginning to end, and understanding how the code and data flows.
- Instead of fixing many test cases in one go, focus on fixing 1 test at a time, each test case should have its own todo item.
- `DragEvent`, `DataTransferItemList`, `DataTransfer`, `DOMRect` are polyfilled and can be used in test:

```ts
const event = new DragEvent('dragenter', {
  cancelable: true,
  bubbles: true,
});
event.dataTransfer?.items.add('hello world', 'text/plain');
```

## Lint

- If you would eslint disable anything, think again and see if there's a better approach to fix it, if you still need to eslint disable, make sure you add -- comment after it to explain why you chose to disable.

### Instead of command X, use Y

- `rg`, `grep` -> use Search tool
- `find` -> `git ls-files` or your own List tool
- `rm` -> try `git rm` first, if fail then try `git clean`
- `head`/`tail`/`cat` -> read the file with tool instead
- `npx tsc` -> `npm run typecheck`
- Don't chain or pipe commands, chained and piped commands will be denied.
